<!-- TOC -->

- [从尾到头打印单链表](#%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E5%8D%95%E9%93%BE%E8%A1%A8)
    - [栈的思路](#%E6%A0%88%E7%9A%84%E6%80%9D%E8%B7%AF)
    - [栈的基本使用](#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8)
    - [解题答案](#%E8%A7%A3%E9%A2%98%E7%AD%94%E6%A1%88)

<!-- /TOC -->
## 从尾到头打印单链表
- 要求方式1: 反向遍历 
  - 解答: 反转链表如上一题, 但会破坏链表结构
- 要求方式2: Stack 栈

### 栈的思路
- 利用栈这个数据结构, 将各个节点压入到栈中  
  然后利用栈先进后出的特性, 实现逆序打印

### 栈的基本使用

```java
public static void main(String args[]){
    //建立一个栈, 其存储的数据类型为String
    Stack<String> stack = new Stack();
    
    //向栈里面加入数据, 即入栈操作
    stack.add("String01");
    stack.add("String02");
    stack.add("String03");

    //取出栈里面的数据, 即出栈操作
    while(stack.size() > 0){
        //stack 的 pop 方法是将栈顶的数据取出的方法
        System.out.println(stack.pop());
    }
}
```

- 执行完毕后的输出结果是
```
String01
String02
String03
```

### 解题答案
- 在测试类中加入该方法即可

```java
public void reversePrint(TheNode head_node){
    //判断链表是否为空
    if(head_node.next == null){
        System.out.println('the list is empty!');
        return;
    }

    //创建一个栈, 将节点压入栈里
    Stack<TheNode> stack = new Stack<TheNode>();
    //创建当前节点指针
    TheNode cur_node = head_node.next;
    //将链表的所有节点压入栈中
    while(cur_node != null){
        stack.push(cur_node);
        cur_node = cur_node.next;
    }

    //取出栈里面的数据, 倒序输出
    while(stack.size() > 0){
        System.out.println(stack.pop());
    }
}
```