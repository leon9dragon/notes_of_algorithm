<!-- TOC -->

- [时间复杂度](#时间复杂度)
    - [度量一个程序执行时间的两种方法](#度量一个程序执行时间的两种方法)
        - [(1)事后统计的方法](#1事后统计的方法)
        - [(2)事前估算的方法](#2事前估算的方法)
    - [时间频度](#时间频度)
        - [基本介绍](#基本介绍)
        - [实例说明](#实例说明)
        - [忽略常数项](#忽略常数项)
        - [忽略低次项](#忽略低次项)

<!-- /TOC -->

## 时间复杂度
### 度量一个程序执行时间的两种方法
#### (1)事后统计的方法
方法可行, 但存在两个缺陷:  
- 要对设计的算法的运行性能进行评估, 需要实际运行程序
- 所得时间的统计量依赖于计算机的软硬件等环境因素

#### (2)事前估算的方法
通过分析某个算法的时间复杂度来判断哪个算法更优

****
### 时间频度
#### 基本介绍
- 一个算法的时间与算法中的语句执行次数成正比  
  哪个算法中语句执行次数多, 它花费时间就越多

- 算法中的语句执行次数称为语句频度或时间频度, 记为 $T(n)$

#### 实例说明
拿计算 1-100 所有数字之和进行示范, 设计了两种算法  
- **第一种算法**  
- 它的时间频度是 T(n) = n+1  
  因为循环语句要执行 n+1 次, 多出的一次是判断跳出循环.  

```java
    int total = 0;
    int end = 100;
    //用for循环计算
    for(int i = 1; i < end; i++){
        total += i;
    }
```

- **第二种算法**
- 它的时间频度 T(n) = 1, 它只需要执行一条语句

```java
    int total = 0;
    int end = 100;
    total = (1 + end) * end / 2
```

#### 忽略常数项
**举例:**  
- $T(2n+20)$ 和 $T(2n)$ 随着 n 变大, 执行曲线无限接近, 20 可以忽略
- $T(3n+10)$ 和 $T(3n)$ 随着 n 变大, 执行曲线无限接近, 10 可以忽略

#### 忽略低次项
**举例:**  
- $T(2n^2+3n+10)$ 与 $T(2n^2)$ 在执行曲线上无限接近, 低次项可以忽略