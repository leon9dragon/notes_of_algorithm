<!-- TOC -->

- [1. 字符串查找算法(KMP)的原理](#1-字符串查找算法kmp的原理)
  - [1.1. 基本介绍](#11-基本介绍)
  - [1.2. 算法应用](#12-算法应用)
  - [1.3. 算法思路](#13-算法思路)
    - [1.3.1. next 数组作用](#131-next-数组作用)
    - [1.3.2. next 数组的创建](#132-next-数组的创建)
    - [1.3.3. 匹配过程](#133-匹配过程)

<!-- /TOC -->

## 1. 字符串查找算法(KMP)的原理

### 1.1. 基本介绍
- KMP 是一个解决模式串在文本串是否出现过的经典算法,  
  它可以返回模式串在文本串中最早出现的位置的结果.

- Knuth-Morris-Pratt 字符串查找算法, 简称为"KMP"算法,  
  常用于在一个文本串 S 内查找一个模式串 P 出现的位置,  
  这个算法由 D.E.Knuth, J.H.Morris 和 V.R.Pratt 三人  
  于 1977 年联合发表, 因此取由这三人的姓氏命名此算法.

- KMP 算法可以利用之前判断过的信息, 通过一个 next 数组,  
  保存模式串中前后最常公共子序列的长度, 每次回溯时,  
  通过 next 数组找到前面匹配过的位置, 省去了大量的时间.

### 1.2. 算法应用
- **字符串匹配问题:**  
  - 有一个文本串 `S="BBC ABCDAB ABCDABCDABDE"` 和一个模式串 `P="ABCDABD"`
  
  - 现在要判断 S 是否有 P, 如果存在则返回第一次出现的位置, 否则返回 -1.
  
### 1.3. 算法思路

#### 1.3.1. next 数组作用
- next 数组用于在模式串和文本串进行匹配时引导模式串指针的指向.
- 首先创建一个 next 数组, 数组长度和模式串字符数量一致.
- next 数组首位初始化为 -1, 用于当字符匹配失败时,  
  如果模式串的指针指向了 next 数组的首位, 会对指针产生新的引导,  
  此时模式串的指针指向模式串首位, 让文本串的指针指向下一位.  

- 一般情况下如果模式串和文本串字符匹配失败, 假设以下情况:  
  - 文本串现在指向了 i 位置, 模式串指向了 j 位置.
  - 则 i 保持不变, j 指针改变指向, 让 j = next[j], 重定向.
  - 改变了 j 指针指向模式串的位置后, 再用新指向位置的字符进行匹配
  - 如果匹配继续失败, 则继续改变指向, 直到 j 指向 next[0]
  - 若指向了 next 数组的 0 号位, 则 j 指针重置为 0, i 后移一位.

- 如果匹配成功则会出现以下情况:  
  - 文本串现在指向了 i 位置, 模式串指向了 j 位置.
  - 如果 S[i] == P[j], i 和 j 一直后移
  - 当匹配完成 i 和 j 都越界, 终止匹配

#### 1.3.2. next 数组的创建
- 这里创建的 next 数组后续可以进一步优化, 但这个是初始版本.  
- 首先创建两个指针, 

#### 1.3.3. 匹配过程
创建两个指针, i 指针对应文本串 S, j 指针对应模式串 P,  
假设现在文本串 S 匹配到 i 位置, 模式串 P 匹配到 j 位置
- 如果 j = -1, 或者当前字符匹配成功(即 S[i] == P[j]),  
  都令 i++, j++, 继续匹配下一个字符；

- 如果 j != -1, 且当前字符匹配失败(即 S[i] != P[j]),  
  则令 i 不变, j = next[j]. 即失配时, 模式串 P 的指针前移 j - next [j] 位.  
  换言之, 当匹配失败时, 模式串前移的位数为:  
  失配字符所在位置 - 失配字符对应的 next 值,  
  即移动的实际位数为: j - next[j], 且此值大于等于 1. 