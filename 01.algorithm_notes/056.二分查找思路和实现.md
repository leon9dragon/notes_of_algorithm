<!-- TOC -->

- [二分查找算法](#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95)
    - [二分查找思路](#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%9D%E8%B7%AF)
    - [代码实现](#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)

<!-- /TOC -->

## 二分查找算法
- 二分查找算法只能对有序数组使用, 以下案例是依据数组由小到大排序进行分析的.

### 二分查找思路
0. 先将目标数组元素由小到大排序, `arr = {1, 8, 10, 89, 1000, 1234}`

1. 首先确定该数组的中间元素的下标 `mid = ( left + right ) / 2`

2. 然后让需要查找的目标 keyVal 和 arr[mid] 进行比较
   - 若 keyVal > arr[mid], 说明目标可能在数组右边, 递归向右查找;
   - 若 keyVal < arr[mid], 说明目标可能在数组左边, 递归向左查找;
   - 若 keyVal == arr[mid], 找到目标, 返回 mid.

3. 结束递归的条件
   - 如果找到目标, 返回序号, 递归结束
   - 若找不到目标, 索引越界, 递归结束

### 代码实现
- 实现细节在注释已说明

```java
package com.leo9.dc18.binary_search;

public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5,6,9};
        int key = 9;
        searchKey(arr, key, 0, arr.length-1);
    }

    public static void searchKey(int[] arr, int key, int left, int right){
        //索引越界时输出并跳出递归
        if(left > right){
            System.out.println("not found");
            return;
        }

        //获取中间索引
        int mid = (left+right)/2;

        if(arr[mid] == key){
            //找到目标值输出并返回
            System.out.printf("found in arr[%d] = %d", mid, arr[mid]);
            return;
        }
        else if(key > arr[mid]){
            //左边界变为mid+1, 保留右边界不变, 因为arr[mid]没必要再比较所以右移一位, 同时右移一位能保证最终可以获取到右边界
            searchKey(arr, key, mid+1, right);
        }
        else if(key < arr[mid]){
            //右边界变为mid-1, 保留左边界不变, 理由同上
            searchKey(arr, key, left, mid-1);
        }
    }
}

```