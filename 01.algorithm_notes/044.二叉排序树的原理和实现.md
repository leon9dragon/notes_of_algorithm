<!-- TOC -->

- [1. 二叉排序树的案例引入](#1-二叉排序树的案例引入)
  - [1.1. 需求](#11-需求)
  - [1.2. 分析](#12-分析)
- [2. 二叉排序树的原理](#2-二叉排序树的原理)
  - [2.1. 基本介绍](#21-基本介绍)
- [3. 二叉排序树的创建和遍历](#3-二叉排序树的创建和遍历)
  - [3.1. 思路分析](#31-思路分析)
  - [3.2. 代码实现](#32-代码实现)
    - [3.2.1. 结点类](#321-结点类)
    - [3.2.2. 二叉树类](#322-二叉树类)
    - [3.2.3. 测试类](#323-测试类)
  - [3.3. 测试结果](#33-测试结果)
- [4. 二叉树删除结点的思路和实现](#4-二叉树删除结点的思路和实现)
  - [4.1. 思路分析](#41-思路分析)
    - [4.1.1. 情况一: 删除叶子结点](#411-情况一-删除叶子结点)
    - [4.1.2. 情况二: 删除只有一棵子树的结点](#412-情况二-删除只有一棵子树的结点)
    - [4.1.3. 情况三: 删除有两棵子树的结点](#413-情况三-删除有两棵子树的结点)

<!-- /TOC -->

## 1. 二叉排序树的案例引入

### 1.1. 需求
给定数列 `arr = {7,3,10,12,5,1,9}`,  
要求能高效的完成对数据的查询和添加.

### 1.2. 分析
- **使用数组**    
> - 数组未排序
>   - 优点: 直接在数组尾部添加, 速度快
>   - 缺点: 查找元素的速度慢
> - 数组已排序
>   - 优点: 可以使用二分查找, 查找速度快
>   - 缺点: 为保证数组有序, 插入新数据都要重新排序,   
>     每次排序都要使数据插入位后的数据整体后移, 速度慢

- **使用链式存储-链表**  
> 优点: 添加数据速度比数组快, 不需要数据整体移动.  
> 缺点: 不管链表是否有序, 查找速度都慢.

- **使用二叉排序树**
> 下面开始进行介绍

****

## 2. 二叉排序树的原理

### 2.1. 基本介绍
- 二叉排序树 Binary Sort(Search) Tree, 简称 BST.  

- 对于二叉排序树的任何一个非叶子结点而言,  
  要求左子结点的值比父结点的值小, 右子结点的值比父结点的值大.  
  如果子结点的值和父结点相同, 可以左右任意放置该子结点.

- 针对前面需求所给出的数组 `arr = {7,3,10,12,5,1,9}` 
  - 对应的二叉排序树如下图所示:  
  ![BST1](../99.images/2020-07-08-15-26-48.png)   
  - 插入一个结点 2 后的图示:  
  ![BST2](../99.images/2020-07-08-15-33-19.png)

****

## 3. 二叉排序树的创建和遍历

### 3.1. 思路分析
- 插入新的结点的时候与调用插入方法的结点进行比较  
  - 如果小于等于调用结点, 则向左进行
    - 若调用方法的结点的左子结点为空, 则直接将新结点挂上去即可
    - 若调用方法的结点的左子结点非空, 则利用其左子结点调用方法
  - 如果大于调用结点, 则向右进行
    - 若调用方法的结点的右子结点为空, 则直接将新结点挂上去即可
    - 若调用方法的结点的右子结点非空, 则利用其右子结点调用方法

### 3.2. 代码实现

#### 3.2.1. 结点类
```java
package com.leo9.dc28.binary_sort_tree;

public class TreeNode {
    public int value;
    public TreeNode left_node;
    public TreeNode right_node;

    public TreeNode(int value) {
        this.value = value;
    }

    //region 添加结点的方法
    //递归形式添加结点, 注意需要满足二叉排序树的要求
    public void addNode(TreeNode new_node) {
        //若传入空结点则直接返回即可
        if (new_node == null) {
            return;
        }

        //region 判断传入的结点的值, 和当前调用方法的结点的值关系
        //如果新结点的值小于等于当前调用结点的值
        if (new_node.value <= this.value) {
            //如果当前调用结点的左子结点为空, 则直接将新结点接在其左子结点即可
            if (this.left_node == null) {
                this.left_node = new_node;
            }
            //如果不为空, 递归向左添加
            else {
                this.left_node.addNode(new_node);
            }
        }
        //如果新结点的值大于当前调用结点的值
        else {
            //如果当前调用结点的右子结点为空, 则直接将新结点接在其右子结点即可
            if (this.right_node == null) {
                this.right_node = new_node;
            }
            //如果不为空, 递归向右添加
            else {
                this.right_node.addNode(new_node);
            }
        }
        //endregion
    }
    //endregion


    @Override
    public String toString() {
        return "TreeNode{" +
                "value=" + value +
                '}';
    }

    //region 中序遍历
    public void infixOrder() {
        if (this.left_node != null) {
            this.left_node.infixOrder();
        }

        System.out.println(this);

        if (this.right_node != null) {
            this.right_node.infixOrder();
        }
    }
    //endregion
}

```

****

#### 3.2.2. 二叉树类
```java
package com.leo9.dc28.binary_sort_tree;

public class BinarySortTree {
    private TreeNode root_node;

    //region 定义添加结点的方法
    public void addNode(TreeNode new_node) {
        //如果根结点为空, 新结点直接成为根结点
        if (root_node == null) {
            root_node = new_node;
        }
        //如果根结点不为空, 则根结点调用增加结点方法
        else {
            root_node.addNode(new_node);
        }
    }
    //endregion

    //region 定义中序遍历方法
    public void infixOrder(){
        if(root_node == null){
            System.out.println("the tree is null!");
            return;
        }
        root_node.infixOrder();
    }
    //endregion
}

```

****

#### 3.2.3. 测试类
```java
package com.leo9.dc28.binary_sort_tree;

public class TestDemoBST {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9};
        BinarySortTree binarySortTree = new BinarySortTree();
        //循环添加结点到二叉排序树
        for (int i = 0; i < arr.length; i++) {
            binarySortTree.addNode(new TreeNode(arr[i]));
        }
        //中序遍历二叉排序树
        System.out.println("=========================");
        binarySortTree.infixOrder();
    }

}

```

### 3.3. 测试结果
- 中序遍历后输出结果为顺序输出结点  
![test](../99.images/2020-07-08-21-26-44.png)

****

## 4. 二叉树删除结点的思路和实现
- 拿下图作为实例进行讲解  
![SAMPLE](../99.images/2020-07-08-21-51-37.png)

- 二叉排序树的删除情况比较复杂, 有下面三种情况需要考虑
  - 删除叶子节点(比如结点: 2, 5, 9, 12)
  - 删除只有一棵子树的结点(比如结点: 1)
  - 删除有两棵子树的结点(比如结点: 7, 3, 10)

### 4.1. 思路分析

#### 4.1.1. 情况一: 删除叶子结点
- 首先要找到目标删除结点(targetNode)是否存在 
- 再找到 targetNode 的父结点(parentNode), 并确定是否存在
- 确定 targetNode 对应 parentNode 的左子结点或是右子结点
- 根据前面的条件进行对应删除操作, 将 parentNode 的左或右子结点置空即可

#### 4.1.2. 情况二: 删除只有一棵子树的结点
- 首先要找到目标删除结点(targetNode)是否存在 
- 再找到 targetNode 的父结点(parentNode), 并确定是否存在
- 确定 targetNode 对应 parentNode 的左子结点或是右子结点
- 如果 targetNode 是 parentNode 的左(右)子结点
  - 将 targetNode 的唯一子节点赋给 parentNode 的左(右)子结点
  - 再将 targetNode 的唯一子结点置空

#### 4.1.3. 情况三: 删除有两棵子树的结点
- 首先要找到目标删除结点(targetNode)是否存在 
- 再找到 targetNode 的父结点(parentNode), 并确定是否存在
- 再从 targetNode 的右子树找到最小的结点(或从左子树中找到最大的结点)
- 然后用一个临时变量, 将找到的右子树最小结点(左子树最大结点)的值进行保存
- 然后将右子树最小结点(左子树最大结点)进行删除
- 最后将 targetNode 的值改为临时变量保存的值即可