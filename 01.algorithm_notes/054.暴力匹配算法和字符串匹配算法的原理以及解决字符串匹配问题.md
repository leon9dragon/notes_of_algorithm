<!-- TOC -->

- [1. 暴力匹配算法的原理](#1-暴力匹配算法的原理)
  - [1.1. 暴力匹配算法应用场景-字符串匹配问题](#11-暴力匹配算法应用场景-字符串匹配问题)
  - [1.2. 暴力匹配算法解决思路](#12-暴力匹配算法解决思路)
    - [1.2.1. 暴力匹配的缺点](#121-暴力匹配的缺点)
  - [1.3. 暴力匹配算法的实现](#13-暴力匹配算法的实现)

<!-- /TOC -->

## 1. 暴力匹配算法的原理

### 1.1. 暴力匹配算法应用场景-字符串匹配问题
1) 有一个字符串 `str1 = "ababcabcacbab"` 和 `str2 = "abcac"`  
     
2) 现在要盘对 str1 中是否包含 str2:  
   - 如果存在, 就返回 str2 在 str 1 中第一次出现的位置;  
   - 如果不存在, 就返回 -1;

### 1.2. 暴力匹配算法解决思路
假设现在 str1 匹配到了 i 位置, str2 匹配到了 j 位置, 则有如下情况:  
- 如果当前字符匹配成功, 即`str1[i] == str2[j]`,  
  则 `i++; j++;` 然后继续匹配下一个字符串.

- 如果匹配失败, 即`str1[i] != str2[j]`,  
  则令 `i=i-j+1; j=0;`, 相当于每次失败的时候 i 回溯,  
  然后 i 再加一到匹配前位置的下一位, 然后 j 重置为 0.

#### 1.2.1. 暴力匹配的缺点
用暴力匹配去解决字符串匹配的话, 会产生大量的回溯,  
每次匹配只移动了一位, 若是匹配不成功, 才移动到下一位,  
整一个匹配下来需要耗费大量的时间, 并不推荐可行.

### 1.3. 暴力匹配算法的实现
