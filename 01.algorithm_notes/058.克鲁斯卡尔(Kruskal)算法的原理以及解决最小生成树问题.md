<!-- TOC -->

- [1. 克鲁斯卡尔(Kruskal)算法的原理](#1-克鲁斯卡尔kruskal算法的原理)
  - [1.1. 算法应用场景-公交站问题](#11-算法应用场景-公交站问题)
  - [1.2. 算法基本介绍](#12-算法基本介绍)
  - [1.3. 算法图解说明](#13-算法图解说明)

<!-- /TOC -->

## 1. 克鲁斯卡尔(Kruskal)算法的原理

### 1.1. 算法应用场景-公交站问题
![pic](../99.images/2020-08-12-13-54-32.png)  
- 某市新增 7 个站点 `{'A','B','C','D','E','F','G'}`, 现要把 7 个站点连通.
- 各个站点的距离用边线表示(权), 比如 `A-B` 距离 12 公里.  
- 如何修路保证各个站点都能连通, 并且修建的公路总里程最短?
- 本质上依旧是最小生成树问题.

### 1.2. 算法基本介绍
- 克鲁斯卡尔算法, 是用来求加权连通图的最小生成树的算法.

- 基本思想:  
  按照权值从小到大的顺序选择 n-1 条边, 并保证这些边不构成回路.

- 具体做法:  
  首先构造一个只含 n 个顶点的森林,  
  根据权值从小到大从连通网中选择边加入到森林中,  
  并使森灵中不产生回路, 直至森林变成一棵树为止.

### 1.3. 算法图解说明
![pic](../99.images/2020-08-12-15-43-49.png)  
- 在含有 n 个顶点的连通图中选择 `n-1` 条边, 构成极小连通子图,  
  并使该连通子图中 `n-1` 条边上的权值之和最小, 称为最小生成树.
  
![pic](../99.images/2020-08-12-15-44-52.png)  
- 如上图所示的连通网可以有多棵权值总和不相同的生成树.

****
- 以上图为例, 来对克鲁斯卡尔进行演示(假设, 用数组 R 保存最小生成树结果).

![s1](../99.images/2020-08-12-16-28-59.png)
- 第1步: 将边 <E,F> 加入 R 中.   
    边 <E,F> 的权值最小, 因此将它加入到最小生成树结果R中.  

![s2](../99.images/2020-08-12-16-29-48.png)
- 第2步: 将边 <C,D> 加入 R 中.    
    上一步操作之后, 边 <C,D> 的权值最小, 因此将它加入到最小生成树结果 R 中.  

![s3](../99.images/2020-08-12-16-30-14.png)
- 第3步: 将边 <D,E> 加入 R 中.  
    上一步操作之后, 边<D,E>的权值最小, 因此将它加入到最小生成树结果R中.  

![s4](../99.images/2020-08-12-16-30-39.png)
- 第4步: 将边<B,F>加入R中.  
    上一步操作之后, 边<C,E>的权值最小, 但<C,E>会和已有的边构成回路;   
    因此, 跳过边<C,E>. 同理, 跳过边<C,F>.  
    将边<B,F>加入到最小生成树结果R中.  

![s5](../99.images/2020-08-12-16-31-16.png)
- 第5步: 将边<E,G>加入R中.  
    上一步操作之后, 边<E,G>的权值最小, 因此将它加入到最小生成树结果R中.  

![s6](../99.images/2020-08-12-16-31-45.png)
- 第6步: 将边<A,B>加入R中.  
    上一步操作之后, 边<F,G>的权值最小, 但<F,G>会和已有的边构成回路;  
    因此, 跳过边<F,G>. 同理，跳过边<B,C>.  
    将边<A,B>加入到最小生成树结果R中.

- 此时, 最小生成树构造完成.   
  它包括的边依次是: <E,F>, <C,D>, <D,E>, <B,F>, <E,G>, <A,B>.